const { 
    default: makeWASocket, 
    DisconnectReason, 
    useMultiFileAuthState,
    fetchLatestBaileysVersion,
    makeCacheableSignalKeyStore
} = require('@whiskeysockets/baileys');
const readline = require('readline-sync');
const fs = require('fs');
const path = require('path');
const { 
    luhnCardGenerator,
    getBinDetails,
    generateCodeBlocks,
    botConfig,
    checkLuhn,
    ccGenerator
} = require('./config');

// Create required directories
const requiredDirs = ['auth', 'downloads', 'FILES'];
requiredDirs.forEach(dir => {
    if (!fs.existsSync(dir)) {
        fs.mkdirSync(dir, { recursive: true });
    }
});

// Create default files if they don't exist
if (!fs.existsSync('FILES/vbvbin.txt')) {
    fs.writeFileSync('FILES/vbvbin.txt', '# VBV BIN Database\n# Format: BIN|STATUS|RESPONSE\n447697|3D TRUE ‚ùå|3D Secure Required\n424242|3D FALSE ‚úÖ|3D Secure Not Required\n');
}

if (!fs.existsSync('FILES/config.json')) {
    fs.writeFileSync('FILES/config.json', JSON.stringify({
        "OWNER_ID": ["1234567890"],
        "THREADS": 5,
        "BOT_NAME": "¬™ùó†ùó∏ùó®ùòÄùóõùòÖùóñùóµùóû"
    }, null, 2));
}

// User database (simple JSON file storage)
const usersDbFile = 'FILES/users.json';
let usersDb = {};
if (fs.existsSync(usersDbFile)) {
    try {
        usersDb = JSON.parse(fs.readFileSync(usersDbFile, 'utf8'));
    } catch (e) {
        usersDb = {};
    }
}

function saveUsersDb() {
    fs.writeFileSync(usersDbFile, JSON.stringify(usersDb, null, 2));
}

async function startBot() {
    const { state, saveCreds } = await useMultiFileAuthState('./auth');
    const { version, isLatest } = await fetchLatestBaileysVersion();
    
    console.log(`Using WA v${version.join('.')}, isLatest: ${isLatest}`);
    
    const sock = makeWASocket({
        version,
        auth: {
            creds: state.creds,
            keys: makeCacheableSignalKeyStore(state.keys, console)
        },
        printQRInTerminal: false,
        browser: ['WhatsApp Bot', 'Chrome', '1.0.0'],
        generateHighQualityLinkPreview: true,
        connectTimeoutMs: 60000,
        defaultQueryTimeoutMs: 60000,
        keepAliveIntervalMs: 30000,
        markOnlineOnConnect: false,
        syncFullHistory: false,
    });

    // Handle connection updates
    sock.ev.on('connection.update', async (update) => {
        const { connection, lastDisconnect } = update;
        
        if (connection === 'close') {
            const shouldReconnect = (lastDisconnect?.error)?.output?.statusCode !== DisconnectReason.loggedOut;
            console.log('Connection closed due to:', lastDisconnect?.error, ', reconnecting:', shouldReconnect);
            
            if (shouldReconnect) {
                console.log('Reconnecting in 5 seconds...');
                setTimeout(() => startBot(), 5000);
            }
        } else if (connection === 'open') {
            console.log('‚úÖ Bot connected successfully!');
            console.log(`üì± Bot Number: ${sock.user?.id}`);
            botConfig.ownerNumber = sock.user?.id;
        } else if (connection === 'connecting') {
            console.log('üîÑ Connecting to WhatsApp...');
        }
    });

    // Handle pairing code with retry logic
    if (!sock.authState.creds.registered) {
        const phoneNumber = readline.question('Enter your WhatsApp number (with country code, e.g., +254712345678): ');
        const cleanNumber = phoneNumber.replace(/[^0-9]/g, '');
        
        let retries = 3;
        while (retries > 0) {
            try {
                console.log(`Requesting pairing code... (${4 - retries}/3)`);
                const code = await sock.requestPairingCode(cleanNumber);
                console.log(`\nüîë Your pairing code: ${code}`);
                console.log('Enter this code in WhatsApp > Linked Devices > Link a Device > Link with phone number instead');
                break;
            } catch (error) {
                console.error(`Attempt ${4 - retries} failed:`, error.message);
                retries--;
                if (retries > 0) {
                    console.log('Retrying in 10 seconds...');
                    await new Promise(resolve => setTimeout(resolve, 10000));
                    return startBot();
                } else {
                    console.error('Failed to get pairing code after 3 attempts');
                    process.exit(1);
                }
            }
        }
    }

    // Save credentials when updated
    sock.ev.on('creds.update', saveCreds);

    // Handle incoming messages
    sock.ev.on('messages.upsert', async (m) => {
        const message = m.messages[0];
        if (!message.message || message.key.fromMe) return;

        const from = message.key.remoteJid;
        const messageText = message.message.conversation || 
                           message.message.extendedTextMessage?.text || '';
        
        const sender = message.key.participant || from;
        const senderName = message.pushName || 'User';
        const userId = from.replace('@s.whatsapp.net', '');
        
        console.log(`üì© Message from ${senderName}: ${messageText}`);

        // Command routing
        try {
            if (messageText.startsWith('/gen') || messageText.startsWith('.gen')) {
                await handleGenCommand(sock, from, messageText, senderName, message.id, userId);
            } else if (messageText.startsWith('/bin') || messageText.startsWith('.bin')) {
                await handleBinCommand(sock, from, messageText, senderName, message.id);
            } else if (messageText.startsWith('/ping') || messageText.startsWith('.ping')) {
                await handlePingCommand(sock, from, senderName);
            } else if (messageText.startsWith('/id') || messageText.startsWith('.id')) {
                await handleIdCommand(sock, from, messageText, senderName, userId);
            } else if (messageText.startsWith('/start') || messageText.startsWith('.start')) {
                await handleStartCommand(sock, from, senderName, userId);
            } else if (messageText.startsWith('/register') || messageText.startsWith('.register')) {
                await handleRegisterCommand(sock, from, senderName, userId);
            } else if (messageText.startsWith('/vbv') || messageText.startsWith('.vbv')) {
                await handleVbvCommand(sock, from, messageText, senderName, userId);
            } else if (messageText.startsWith('/mvbv') || messageText.startsWith('.mvbv')) {
                await handleMassVbvCommand(sock, from, messageText, senderName, userId);
            } else if (messageText.startsWith('/addvbv') || messageText.startsWith('.addvbv')) {
                await handleAddVbvCommand(sock, from, messageText, senderName, userId);
            } else if (messageText.startsWith('/rmvbv') || messageText.startsWith('.rmvbv')) {
                await handleRemoveVbvCommand(sock, from, messageText, senderName, userId);
            } else if (messageText.startsWith('/ad') || messageText.startsWith('.ad')) {
                await handleAdyenCommand(sock, from, messageText, senderName, userId);
            } else if (messageText.startsWith('/b4') || messageText.startsWith('.b4')) {
                await handleBraintreeCommand(sock, from, messageText, senderName, userId);
            } else if (messageText.startsWith('/help') || messageText.startsWith('.help')) {
                await handleHelpCommand(sock, from, senderName);
            }
        } catch (error) {
            console.error('Error handling command:', error);
            await sock.sendMessage(from, {
                text: '‚ùå An error occurred while processing your command.'
            });
        }
    });

    return sock;
}

// Helper functions
function isOwner(userId) {
    const config = JSON.parse(fs.readFileSync('FILES/config.json', 'utf8'));
    return config.OWNER_ID.includes(userId);
}

function getUser(userId) {
    return usersDb[userId] || null;
}

function createUser(userId, username, firstName) {
    const user = {
        id: userId,
        username: username || 'N/A',
        firstName: firstName || 'User',
        credits: 100,
        status: 'FREE',
        registeredAt: new Date().toISOString(),
        lastUsed: new Date().getTime()
    };
    usersDb[userId] = user;
    saveUsersDb();
    return user;
}

function updateUser(userId, updates) {
    if (usersDb[userId]) {
        Object.assign(usersDb[userId], updates);
        saveUsersDb();
    }
}

function deductCredits(userId, amount = 1) {
    if (usersDb[userId]) {
        usersDb[userId].credits = Math.max(0, usersDb[userId].credits - amount);
        saveUsersDb();
    }
}

function extractCCs(text) {
    const ccPattern = /(\d{13,19})\|(\d{1,2})\|(\d{2,4})\|(\d{3,4})/g;
    const matches = [];
    let match;
    while ((match = ccPattern.exec(text)) !== null) {
        matches.push(match[0]);
    }
    return matches;
}

// Command handlers
async function handleGenCommand(sock, from, messageText, senderName, messageId, userId) {
    try {
        const parts = messageText.split(' ');
        if (parts.length < 2) {
            const helpText = `Wrong Format ‚ùå

Usage:
Only Bin
\`/gen 447697\`

With Expiration
\`/gen 447697|12\`
\`/gen 447697|12|23\`

With CVV
\`/gen 447697|12|23|000\`

With Custom Amount
\`/gen 447697 100\``;

            await sock.sendMessage(from, { text: helpText });
            return;
        }

        const ccsdata = parts[1];
        const ccParts = ccsdata.split('|');
        const cc = ccParts[0];
        const mes = ccParts[1] || "None";
        const ano = ccParts[2] || "None";
        const cvv = ccParts[3] || "None";

        let amount = 10; // Default amount
        if (parts.length > 2) {
            const parsedAmount = parseInt(parts[2]);
            if (!isNaN(parsedAmount)) {
                amount = parsedAmount;
            }
        }

        if (amount > 10000) {
            await sock.sendMessage(from, {
                text: `*Limit Reached ‚ö†Ô∏è*

Message: Maximum Generated Amount is 10K.`
            });
            return;
        }

        const deleteMsg = await sock.sendMessage(from, {
            text: "*Generating...*"
        });

        const start = Date.now();
        const binDetails = await getBinDetails(cc.substring(0, 6));
        const [brand, type, level, bank, country, flag, currency] = binDetails;
        const allCards = luhnCardGenerator(cc, mes, ano, cvv, amount);
        
        await sock.sendMessage(from, { delete: deleteMsg.key });
        const timeTaken = ((Date.now() - start) / 1000).toFixed(2);

        if (amount === 10) {
            const response = `- ùêÇùêÇ ùêÜùêûùêßùêöùê´ùêöùê≠ùêûùêù ùêíùêÆùêúùêúùêûùê¨ùê¨ùêüùêÆùê•ùê•ùê≤
- ùêÅùê¢ùêß - \`${cc}\`
- ùêÄùê¶ùê®ùêÆùêßùê≠ - ${amount}

${generateCodeBlocks(allCards)}
- ùóúùóªùó≥ùóº - ${brand} - ${type} - ${level}
- ùêÅùêöùêßùê§ - ${bank} üèõ
- ùêÇùê®ùêÆùêßùê≠ùê´ùê≤ - ${country} - ${flag}

- ùêìùê¢ùê¶ùêû: - ${timeTaken} ùê¨ùêûùêúùê®ùêßùêùùê¨
- ùêÇùê°ùêûùêúùê§ùêûùêù - ${senderName} [ User ]`;

            await sock.sendMessage(from, { text: response });
        } else {
            const filename = `downloads/${amount}x_CC_Generated_By_${userId}.txt`;
            fs.writeFileSync(filename, allCards);

            const caption = `- ùêÅùê¢ùêß: \`${cc}\`
- ùêÄùê¶ùê®ùêÆùêßùê≠: ${amount}

- ùóúùóªùó≥ùóº - ${brand} - ${type} - ${level}
- ùêÅùêöùêßùê§ - ${bank} üèõ
- ùêÇùê®ùêÆùêßùê≠ùê´ùê≤ - ${country} - ${flag} - ${currency}

- ùêìùê¢ùê¶ùêû - ${timeTaken} ùê¨ùêûùêúùê®ùêßùêùùê¨
- ùêÇùê°ùêûùêúùê§ùêûùêù - ${senderName} ‚§ø User ‚§æ`;

            await sock.sendMessage(from, {
                document: fs.readFileSync(filename),
                fileName: `${amount}x_CC_Generated.txt`,
                mimetype: 'text/plain',
                caption: caption
            });

            fs.unlinkSync(filename);
        }

        console.log(`‚úÖ Generated ${amount} cards for ${senderName}`);

    } catch (error) {
        console.error('Generation error:', error);
        await sock.sendMessage(from, {
            text: '‚ùå Error generating cards. Please try again with valid parameters.'
        });
    }
}

async function handleBinCommand(sock, from, messageText, senderName, messageId) {
    try {
        const parts = messageText.split(' ');
        if (parts.length < 2) {
            const helpText = `ùêàùêßùêØùêöùê•ùê¢ùêù ùêÅùêàùêç ‚ö†Ô∏è

ùêåùêûùê¨ùê¨ùêöùê†ùêû: ùêçùê® ùêïùêöùê•ùê¢ùêù ùêÅùêàùêç ùê∞ùêöùê¨ ùêüùê®ùêÆùêßùêù ùê¢ùêß ùê≤ùê®ùêÆùê´ ùê¢ùêßùê©ùêÆùê≠.

Usage: /bin 447697`;
            await sock.sendMessage(from, { text: helpText });
            return;
        }

        const bin = parts[1].substring(0, 6);
        const binDetails = await getBinDetails(bin);
        const [brand, type, level, bank, country, flag, currency] = binDetails;

        const response = `ùóïùóúùó° ùóüùóºùóºùó∏ùòÇùóΩ ùó•ùó≤ùòÄùòÇùóπùòÅ üîç

ùóïùóúùó°: \`${bin}\`
ùóúùóªùó≥ùóº: \`${brand} - ${type} - ${level}\`
ùêÅùêöùêßùê§: \`${bank} üèõ\`
ùêÇùê®ùêÆùêßùê≠ùê´ùê≤: \`${country} ${flag}\``;

        await sock.sendMessage(from, { text: response });
    } catch (error) {
        console.error('BIN lookup error:', error);
        await sock.sendMessage(from, {
            text: '‚ùå Error looking up BIN information.'
        });
    }
}

async function handlePingCommand(sock, from, senderName) {
    try {
        const start = Date.now();
        const pingMsg = await sock.sendMessage(from, { 
            text: 'ü§ñ Checking ¬™ùó†ùó∏ùó®ùòÄùóõùòÖùóñùóµùóû Ping...' 
        });
        const end = Date.now();
        
        const response = `ü§ñ Bot Name: ¬™ùó†ùó∏ùó®ùòÄùóõùòÖùóñùóµùóû 
‚úÖ Bot Status: Running
üì∂ Ping: ${end - start} ms`;

        await sock.sendMessage(from, {
            text: response,
            edit: pingMsg.key
        });
    } catch (error) {
        console.error('Ping error:', error);
    }
}

async function handleIdCommand(sock, from, messageText, senderName, userId) {
    try {
        const response = `Hey ${senderName}!
Your User ID: \`${userId}\`
This Chat ID: \`${from}\``;

        await sock.sendMessage(from, { text: response });
    } catch (error) {
        console.error('ID command error:', error);
    }
}

async function handleStartCommand(sock, from, senderName, userId) {
    try {
        const frames = [
            '¬™', '¬™ùó†', '¬™ùó†ùó∏', '¬™ùó†ùó∏ùó®', '¬™ùó†ùó∏ùó®ùòÄ', 
            '¬™ùó†ùó∏ùó®ùòÄùóõ', '¬™ùó†ùó∏ùó®ùòÄùóõùòÖ', '¬™ùó†ùó∏ùó®ùòÄùóõùòÖùóñ', 
            '¬™ùó†ùó∏ùó®ùòÄùóõùòÖùóñùóµ', '¬™ùó†ùó∏ùó®ùòÄùóõùòÖùóñùóµùóû'
        ];

        const startMsg = await sock.sendMessage(from, { text: frames[0] });
        
        for (let i = 1; i < frames.length; i++) {
            await new Promise(resolve => setTimeout(resolve, 200));
            await sock.sendMessage(from, {
                text: frames[i],
                edit: startMsg.key
            });
        }

        await new Promise(resolve => setTimeout(resolve, 500));
        
        const welcomeText = `üåü ùóõùó≤ùóπùóπùóº ${senderName}!

ùó™ùó≤ùóπùó∞ùóºùó∫ùó≤ ùóÆùóØùóºùóÆùóøùó± ùòÅùóµùó≤ ¬™ùó†ùó∏ùó®ùòÄùóõùòÖùóñùóµùóû! üöÄ

ùóú ùóÆùó∫ ùòÜùóºùòÇùóø ùó¥ùóº-ùòÅùóº ùóØùóºùòÅ, ùóΩùóÆùó∞ùó∏ùó≤ùó± ùòÑùó∂ùòÅùóµ ùóÆ ùòÉùóÆùóøùó∂ùó≤ùòÅùòÜ ùóºùó≥ ùó¥ùóÆùòÅùó≤ùòÄ, ùòÅùóºùóºùóπùòÄ, ùóÆùóªùó± ùó∞ùóºùó∫ùó∫ùóÆùóªùó±ùòÄ.

üëá ùóßùóÆùóΩ /register ùòÅùóº ùóØùó≤ùó¥ùó∂ùóª ùòÜùóºùòÇùóø ùó∑ùóºùòÇùóøùóªùó≤ùòÜ.
üëá ùóóùó∂ùòÄùó∞ùóºùòÉùó≤ùóø ùó∫ùòÜ ùó≥ùòÇùóπùóπ ùó∞ùóÆùóΩùóÆùóØùó∂ùóπùó∂ùòÅùó∂ùó≤ùòÄ ùòÑùó∂ùòÅùóµ /help`;

        await sock.sendMessage(from, {
            text: welcomeText,
            edit: startMsg.key
        });
    } catch (error) {
        console.error('Start command error:', error);
    }
}

async function handleRegisterCommand(sock, from, senderName, userId) {
    try {
        const user = getUser(userId);
        
        if (user) {
            const response = `ùóîùóπùóøùó≤ùóÆùó±ùòÜ ùó•ùó≤ùó¥ùó∂ùòÄùòÅùó≤ùóøùó≤ùó± ‚ö†Ô∏è

ùó†ùó≤ùòÄùòÄùóÆùó¥ùó≤: ùó¨ùóºùòÇ ùóÆùóøùó≤ ùóÆùóπùóøùó≤ùóÆùó±ùòÜ ùóøùó≤ùó¥ùó∂ùòÄùòÅùó≤ùóøùó≤ùó± ùó∂ùóª ùóºùòÇùóø ùóØùóºùòÅ.

ùóòùòÖùóΩùóπùóºùóøùó≤ ùó∫ùòÜ ùó∞ùóºùó∫ùó∫ùóÆùóªùó±ùòÄ ùòÑùó∂ùòÅùóµ /help`;
        } else {
            createUser(userId, 'N/A', senderName);
            const response = `ùó•ùó≤ùó¥ùó∂ùòÄùòÅùóøùóÆùòÅùó∂ùóºùóª ùó¶ùòÇùó∞ùó∞ùó≤ùòÄùòÄùó≥ùòÇùóπ ‚ôªÔ∏è 
‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ
‚óè ùó°ùóÆùó∫ùó≤: ${senderName}
‚óè ùó®ùòÄùó≤ùóø ùóúùóó: ${userId}
‚óè ùó•ùóºùóπùó≤: Free
‚óè ùóñùóøùó≤ùó±ùó∂ùòÅùòÄ: 100

ùó†ùó≤ùòÄùòÄùóÆùó¥ùó≤: ùó¨ùóºùòÇ ùó¥ùóºùòÅ 100 ùó∞ùóøùó≤ùó±ùó∂ùòÅùòÄ ùóÆùòÄ ùóøùó≤ùó¥ùó∂ùòÄùòÅùóøùóÆùòÅùó∂ùóºùóª ùóØùóºùóªùòÇùòÄ.

ùóòùòÖùóΩùóπùóºùóøùó≤ ùó∫ùòÜ ùòÉùóÆùóøùó∂ùóºùòÇùòÄ ùó∞ùóºùó∫ùó∫ùóÆùóªùó±ùòÄ ùòÑùó∂ùòÅùóµ /help`;
        }

        await sock.sendMessage(from, { text: response });
    } catch (error) {
        console.error('Register error:', error);
    }
}

async function handleVbvCommand(sock, from, messageText, senderName, userId) {
    try {
        const user = getUser(userId);
        if (!user) {
            await sock.sendMessage(from, { text: 'Please register first with /register' });
            return;
        }

        const parts = messageText.split(' ');
        if (parts.length < 2) {
            const helpText = `Gate Name: 3DS Lookup ‚ôªÔ∏è
CMD: /vbv

Message: No CC Found in your input ‚ùå

Usage: /vbv cc|mes|ano|cvv`;
            await sock.sendMessage(from, { text: helpText });
            return;
        }

        const ccData = parts[1];
        const ccParts = ccData.split('|');
        const cc = ccParts[0];
        const bin = cc.substring(0, 6);

        if (bin.startsWith('3')) {
            await sock.sendMessage(from, { text: 'Unsupported card type.' });
            return;
        }

        const processingMsg = await sock.sendMessage(from, { text: 'Processing your request...' });

        const vbvData = fs.readFileSync('FILES/vbvbin.txt', 'utf8').split('\n');
        let binFound = false;
        let binResponse = 'Not Found';
        let responseMessage = 'Lookup Card Error';
        let approve = 'ùó•ùó≤ùó∑ùó≤ùó∞ùòÅùó≤ùó± ‚ùå';

        for (const line of vbvData) {
            if (line.startsWith(bin)) {
                binFound = true;
                const parts = line.trim().split('|');
                binResponse = parts[1] || 'Unknown';
                responseMessage = parts[2] || 'Unknown Response';
                if (!binResponse.includes('3D TRUE ‚ùå')) {
                    approve = 'ùó£ùóÆùòÄùòÄùó≤ùó± ‚úÖ';
                }
                break;
            }
        }

        const start = Date.now();
        const binDetails = await getBinDetails(bin);
        const [brand, type, level, bank, country, flag] = binDetails;
        const timeTaken = ((Date.now() - start) / 1000).toFixed(2);

        const response = `${approve}
        
ùóñùóÆùóøùó± ‚áæ \`${ccData}\`
ùêÜùêöùê≠ùêûùê∞ùêöùê≤ ‚áæ 3DS Lookup
ùêëùêûùê¨ùê©ùê®ùêßùê¨ùêû ‚áæ ${responseMessage}

ùóúùóªùó≥ùóº ‚áæ ${brand} - ${type} - ${level}
ùêàùê¨ùê¨ùêÆùêûùê´ ‚áæ ${bank}
ùêÇùê®ùêÆùêßùê≠ùê´ùê≤ ‚áæ ${country} ${flag}

ùóßùó∂ùó∫ùó≤ ‚áæ ${timeTaken} ùòÄùó≤ùó∞ùóºùóªùó±ùòÄ`;

        await sock.sendMessage(from, {
            text: response,
            edit: processingMsg.key
        });

        deductCredits(userId, 1);
    } catch (error) {
        console.error('VBV error:', error);
    }
}

async function handleMassVbvCommand(sock, from, messageText, senderName, userId) {
    try {
        const user = getUser(userId);
        if (!user) {
            await sock.sendMessage(from, { text: 'Please register first with /register' });
            return;
        }

        const ccs = extractCCs(messageText);
        if (ccs.length === 0) {
            await sock.sendMessage(from, { text: 'No valid credit cards found in your message.' });
            return;
        }

        if (ccs.length > 25) {
            await sock.sendMessage(from, { text: `Error: Maximum 25 CCs allowed. You provided ${ccs.length}.` });
            return;
        }

        const processingMsg = await sock.sendMessage(from, { text: 'Processing your request...' });
        const vbvData = fs.readFileSync('FILES/vbvbin.txt', 'utf8').split('\n');

        let response = `MASS VBV CHECK [/mvbv]

Number Of CC Check : [${ccs.length} / 25]

`;

        const start = Date.now();

        for (const cc of ccs) {
            const bin = cc.split('|')[0].substring(0, 6);
            let status = 'Error';
            let responseText = 'Lookup Card Error';

            if (bin.startsWith('3')) {
                status = 'Card Error';
                responseText = 'Unsupported card type.';
            } else {
                for (const line of vbvData) {
                    if (line.startsWith(bin)) {
                        const parts = line.trim().split('|');
                        status = parts[1] || 'Unknown';
                        responseText = parts[2] || 'Unknown Response';
                        break;
                    }
                }
            }

            response += `Card‚ÜØ \`${cc}\`
**Status - ${status}**
**Result -‚§ø ${responseText} ‚§æ**

`;
        }

        const timeTaken = ((Date.now() - start) / 1000).toFixed(2);
        response += `ùóßùó∂ùó∫ùó≤ ‚áæ ${timeTaken} ùòÄùó≤ùó∞ùóºùóªùó±ùòÄ`;

        await sock.sendMessage(from, {
            text: response,
            edit: processingMsg.key
        });

        deductCredits(userId, ccs.length);
    } catch (error) {
        console.error('Mass VBV error:', error);
    }
}

async function handleAddVbvCommand(sock, from, messageText, senderName, userId) {
    try {
        if (!isOwner(userId)) {
            await sock.sendMessage(from, { 
                text: `You Don't Have Permission To Use This Command.
Contact Bot Owner!` 
            });
            return;
        }

        const parts = messageText.split(' ');
        if (parts.length < 2) {
            await sock.sendMessage(from, { text: 'Usage: /addvbv BIN|STATUS|RESPONSE' });
            return;
        }

        const newToken = parts.slice(1).join(' ').trim();
        const newBin = newToken.split('|')[0].trim();

        const vbvData = fs.readFileSync('FILES/vbvbin.txt', 'utf8').split('\n');
        const updatedTokens = vbvData.filter(line => !line.startsWith(newBin));
        
        updatedTokens.push(newToken);
        fs.writeFileSync('FILES/vbvbin.txt', updatedTokens.join('\n'));

        const response = `VBV_TOKEN Successfully Added ‚úÖ
‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ
${newToken}

Status: Successful`;

        await sock.sendMessage(from, { text: response });
    } catch (error) {
        console.error('Add VBV error:', error);
    }
}

async function handleRemoveVbvCommand(sock, from, messageText, senderName, userId) {
    try {
        if (!isOwner(userId)) {
            await sock.sendMessage(from, { 
                text: `You Don't Have Permission To Use This Command.
Contact Bot Owner!` 
            });
            return;
        }

        const parts = messageText.split(' ');
        if (parts.length < 2) {
            await sock.sendMessage(from, { text: 'Usage: /rmvbv BIN' });
            return;
        }

        const binToRemove = parts[1].trim();
        const vbvData = fs.readFileSync('FILES/vbvbin.txt', 'utf8').split('\n');
        const updatedTokens = vbvData.filter(line => !line.startsWith(binToRemove));

        if (updatedTokens.length === vbvData.length) {
            await sock.sendMessage(from, { text: `No matching token found for BIN: ${binToRemove}` });
            return;
        }

        fs.writeFileSync('FILES/vbvbin.txt', updatedTokens.join('\n'));

        const response = `VBV_TOKEN Successfully Removed ‚úÖ
‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ
BIN: ${binToRemove}

Status: Successful`;

        await sock.sendMessage(from, { text: response });
    } catch (error) {
        console.error('Remove VBV error:', error);
    }
}

async function handleAdyenCommand(sock, from, messageText, senderName, userId) {
    try {
        const user = getUser(userId);
        if (!user) {
            await sock.sendMessage(from, { text: 'Please register first with /register' });
            return;
        }

        const parts = messageText.split(' ');
        if (parts.length < 2) {
            const helpText = `Gate Name: Adyen Auth ‚ôªÔ∏è
CMD: /ad

Message: No CC Found in your input ‚ùå

Usage: /ad cc|mes|ano|cvv`;
            await sock.sendMessage(from, { text: helpText });
            return;
        }

        const ccData = parts[1];
        const ccParts = ccData.split('|');
        const [cc, mes, ano, cvv] = ccParts;

        const progressMsg = await sock.sendMessage(from, { 
            text: `‚ÜØ Checking.

- ùêÇùêöùê´ùêù - \`${ccData}\` 
- ùêÜùêöùê≠ùêûùê∞ùêöùê≤ -  Adyen Auth
- ùêëùêûùê¨ùê©ùê®ùêßùê¨ùêû - ‚ñ†‚ñ°‚ñ°‚ñ°` 
        });

        await new Promise(resolve => setTimeout(resolve, 500));
        await sock.sendMessage(from, {
            text: `‚ÜØ Checking..

- ùêÇùêöùê´ùêù - \`${ccData}\` 
- ùêÜùêöùê≠ùêûùê∞ùêöùê≤ -  Adyen Auth
- ùêëùêûùê¨ùê©ùê®ùêßùê¨ùêû - ‚ñ†‚ñ†‚ñ†‚ñ°`,
            edit: progressMsg.key
        });

        await new Promise(resolve => setTimeout(resolve, 500));
        await sock.sendMessage(from, {
            text: `‚ÜØ Checking...

- ùêÇùêöùê´ùêù - \`${ccData}\` 
- ùêÜùêöùê≠ùêûùê∞ùêöùê≤ -  Adyen Auth
- ùêëùêûùê¨ùê©ùê®ùêßùê¨ùêû - ‚ñ†‚ñ†‚ñ†‚ñ†`,
            edit: progressMsg.key
        });

        const start = Date.now();
        const binDetails = await getBinDetails(cc.substring(0, 6));
        const [brand, type, level, bank, country, flag, currency] = binDetails;
        
        // Simulate payment processing
        await new Promise(resolve => setTimeout(resolve, 1000));
        
        // Mock response (replace with actual payment processing)
        const isApproved = Math.random() > 0.7; // 30% approval rate
        const status = isApproved ? 'ùêÄùê©ùê©ùê´ùê®ùêØùêûùêù ‚úÖ' : 'ùêÉùêûùêúùê•ùê¢ùêßùêûùêù ‚ùå';
        const response = isApproved ? 'Auth Success' : 'Card was declined';
        
        const timeTaken = ((Date.now() - start) / 1000).toFixed(2);

        const finalResponse = `${status}

ùóñùóÆùóøùó±- \`${ccData}\` 
ùêÜùêöùê≠ùêûùê∞ùêöùê≤- Adyen Auth
ùêëùêûùê¨ùê©ùê®ùêßùê¨ùêû- ‚§ø ${response} ‚§æ

ùóúùóªùó≥ùóº- ${brand} - ${type} - ${level}
ùêÅùêöùêßùê§- ${bank} 
ùêÇùê®ùêÆùêßùê≠ùê´ùê≤- ${country} - ${flag} - ${currency}

ùóßùó∂ùó∫ùó≤- ${timeTaken} ùê¨ùêûùêúùê®ùêßùêùùê¨`;

        await sock.sendMessage(from, {
            text: finalResponse,
            edit: progressMsg.key
        });

        deductCredits(userId, 1);
    } catch (error) {
        console.error('Adyen error:', error);
    }
}

async function handleBraintreeCommand(sock, from, messageText, senderName, userId) {
    try {
        const user = getUser(userId);
        if (!user) {
            await sock.sendMessage(from, { text: 'Please register first with /register' });
            return;
        }

        const parts = messageText.split(' ');
        if (parts.length < 2) {
            const helpText = `Gate Name: Braintree Auth 3 ‚ôªÔ∏è
CMD: /b4

Message: No CC Found in your input ‚ùå

Usage: /b4 cc|mes|ano|cvv`;
            await sock.sendMessage(from, { text: helpText });
            return;
        }

        const ccData = parts[1];
        const ccParts = ccData.split('|');
        const [cc, mes, ano, cvv] = ccParts;

        const progressMsg = await sock.sendMessage(from, { 
            text: `‚ÜØ Checking.

- ùóñùóÆùóøùó± - \`${ccData}\` 
- ùêÜùêöùê≠ùêûùê∞ùêöùê≤ -  Braintree Auth 3
- ùêëùêûùê¨ùê©ùê®ùêßùê¨ùêû - ‚ñ†‚ñ°‚ñ°‚ñ°` 
        });

        await new Promise(resolve => setTimeout(resolve, 500));
        await sock.sendMessage(from, {
            text: `‚ÜØ Checking..

- ùóñùóÆùóøùó± - \`${ccData}\` 
- ùêÜùêöùê≠ùêûùê∞ùêöùê≤ -  Braintree Auth 3
- ùêëùêûùê¨ùê©ùê®ùêßùê¨ùêû - ‚ñ†‚ñ†‚ñ†‚ñ°`,
            edit: progressMsg.key
        });

        await new Promise(resolve => setTimeout(resolve, 500));
        await sock.sendMessage(from, {
            text: `‚ÜØ Checking...

- ùóñùóÆùóøùó± - \`${ccData}\` 
- ùêÜùêöùê≠ùêûùê∞ùêöùê≤ -  Braintree Auth 3
- ùêëùêûùê¨ùê©ùê®ùêßùê¨ùêû - ‚ñ†‚ñ†‚ñ†‚ñ†`,
            edit: progressMsg.key
        });

        const start = Date.now();
        const binDetails = await getBinDetails(cc.substring(0, 6));
        const [brand, type, level, bank, country, flag, currency] = binDetails;
        
        // Simulate payment processing
        await new Promise(resolve => setTimeout(resolve, 1000));
        
        // Mock response
        const isApproved = Math.random() > 0.75; // 25% approval rate
        const status = isApproved ? 'ùêÄùê©ùê©ùê´ùê®ùêØùêûùêù ‚úÖ' : 'ùêÉùêûùêúùê•ùê¢ùêßùêûùêù ‚ùå';
        const response = isApproved ? '1000: Approved' : 'Gateway Rejected: cvv';
        
        const timeTaken = ((Date.now() - start) / 1000).toFixed(2);

        const finalResponse = `${status}

ùóñùóÆùóøùó±- \`${ccData}\` 
ùêÜùêöùê≠ùêûùê∞ùêöùê≤- Braintree Auth 3
ùêëùêûùê¨ùê©ùê®ùêßùê¨ùêû- ‚§ø ${response} ‚§æ

ùóúùóªùó≥ùóº- ${brand} - ${type} - ${level}
ùêÅùêöùêßùê§- ${bank} 
ùêÇùê®ùêÆùêßùê≠ùê´ùê≤- ${country} - ${flag} - ${currency}

ùóßùó∂ùó∫ùó≤- ${timeTaken} ùê¨ùêûùêúùê®ùêßùêùùê¨`;

        await sock.sendMessage(from, {
            text: finalResponse,
            edit: progressMsg.key
        });

        deductCredits(userId, 1);
    } catch (error) {
        console.error('Braintree error:', error);
    }
}

async function handleHelpCommand(sock, from, senderName) {
    try {
        const helpText = `ùóõùó≤ùóπùóπùóº ${senderName}!

¬™ùó†ùó∏ùó®ùòÄùóõùòÖùóñùóµùóû ùóõùóÆùòÄ ùóΩùóπùó≤ùóªùòÅùòÜ ùóºùó≥ ùóñùóºùó∫ùó∫ùóÆùóªùó±ùòÄ

**üì± BASIC COMMANDS:**
‚Ä¢ /start - Welcome message
‚Ä¢ /register - Register for the bot
‚Ä¢ /ping - Check bot status
‚Ä¢ /id - Get your user ID
‚Ä¢ /help - Show this help

**üí≥ CC TOOLS:**
‚Ä¢ /gen - Generate credit cards
‚Ä¢ /bin - BIN lookup

**üîí VBV SYSTEM:**
‚Ä¢ /vbv - Single VBV check
‚Ä¢ /mvbv - Mass VBV check
‚Ä¢ /addvbv - Add VBV token (Owner only)
‚Ä¢ /rmvbv - Remove VBV token (Owner only)

**üö™ PAYMENT GATES:**
‚Ä¢ /ad - Adyen Auth gate
‚Ä¢ /b4 - Braintree Auth gate

**Examples:**
\`/gen 447697 10\`
\`/bin 447697\`
\`/vbv 4532123456789012|12|25|123\`
\`/ad 4532123456789012|12|25|123\`

ùóòùóªùó∑ùóºùòÜ ùòÇùòÄùó∂ùóªùó¥ ùòÅùóµùó≤ ùóØùóºùòÅ! üöÄ`;

        await sock.sendMessage(from, { text: helpText });
    } catch (error) {
        console.error('Help error:', error);
    }
}

// Handle process termination
process.on('SIGINT', () => {
    console.log('\nüëã Bot shutting down...');
    process.exit(0);
});

process.on('uncaughtException', (error) => {
    console.error('Uncaught Exception:', error);
    console.log('Restarting bot in 5 seconds...');
    setTimeout(() => startBot(), 5000);
});

process.on('unhandledRejection', (error) => {
    console.error('Unhandled Rejection:', error);
});

// Start the bot
console.log('üöÄ Starting WhatsApp Bot...');
startBot().catch(error => {
    console.error('Failed to start bot:', error);
    console.log('Retrying in 10 seconds...');
    setTimeout(() => startBot(), 10000);
});
